.TH "D:/RobotSimulator/test/robot_society/robot society beta/Common/dxf_parse.cpp" 3 "화 1월 27 2015" "Version Ver 1.0.0" "Test" \" -*- nroff -*-
.ad l
.nh
.SH NAME
D:/RobotSimulator/test/robot_society/robot society beta/Common/dxf_parse.cpp \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'StdAfx\&.h'\fP
.br
\fC#include <float\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include 'dxf_parse\&.h'\fP
.br

.SS "매크로"

.in +1c
.ti -1c
.RI "#define \fBBUFSIZE\fP   2048"
.br
.in -1c
.SS "함수"

.in +1c
.ti -1c
.RI "int \fBgetline\fP (FILE *infile, char linbuf[\fBBUFSIZE\fP], int buf_size)"
.br
.ti -1c
.RI "void \fBwriteobj\fP (vector< \fBDXF_ENTITY_ITEM\fP > *items, char curobj[80])"
.br
.ti -1c
.RI "int \fBload_dxf\fP (const char *file_name, vector< \fBDXF_ENTITY_ITEM\fP > *items)"
.br
.in -1c
.SS "변수"

.in +1c
.ti -1c
.RI "static float \fBxcoords\fP [10]"
.br
.ti -1c
.RI "static float \fBycoords\fP [10]"
.br
.ti -1c
.RI "static float \fBzcoords\fP [10]"
.br
.ti -1c
.RI "static float \fBfloats\fP [10]"
.br
.ti -1c
.RI "static float \fBangles\fP [10]"
.br
.ti -1c
.RI "static int \fBints\fP [10]"
.br
.in -1c
.SH "매크로 문서화"
.PP 
.SS "#define BUFSIZE   2048"

.PP
dxf_parse\&.cpp 파일의 8 번째 라인에서 정의되었습니다\&.
.SH "함수 문서화"
.PP 
.SS "int getline (FILE * infile, char linbuf[BUFSIZE], int buf_size)"

.PP
dxf_parse\&.cpp 파일의 16 번째 라인에서 정의되었습니다\&.
.PP
.nf
17 {
18     fgets (linbuf, buf_size, infile);   // get a line from \&.DXF
19 
20     if (feof (infile)) {
21         return -1;
22     }
23     
24     int groupcode;
25 
26     sscanf (linbuf, "%3d", &groupcode);  // scan out group code
27     fgets (linbuf, buf_size, infile);   // get a line from \&.DXF
28     
29     if (feof(infile)) {
30         return -1;
31     }
32     return groupcode;
33 }
.fi
.SS "int load_dxf (const char * file_name, vector< \fBDXF_ENTITY_ITEM\fP > * items)"

.PP
dxf_parse\&.cpp 파일의 135 번째 라인에서 정의되었습니다\&.
.PP
.nf
136 {
137     FILE *infile;
138 
139     if (!(infile = fopen(file_name, "r"))) {
140         TRACE ("DXF LD: Cannot open input file %s!", file_name);
141         return -1;
142     }
143     
144     char curobj[80] = "";   // not working on any object currently
145     int curcolor = 7;       // and it also doesn't have a color yet\&.\&.\&.
146     
147 find:   
148     while (!feof(infile)) {
149         // run file up to the "ENTITIES" section
150         char linbuf[BUFSIZE];
151         int groupcode = getline(infile, linbuf, BUFSIZE);
152         
153         if (groupcode < 0) {        
154             // get a group code and a line
155             goto stopit;
156         }
157         else if (groupcode == 0) {
158             // file section mark
159             if (strstr(linbuf, "EOF")) {
160                 goto stopit;
161             }
162             if (strstr(linbuf, "SECTION")) {
163                 char linbuf[BUFSIZE];
164                 int groupcode = getline(infile, linbuf, BUFSIZE);
165 
166                 if (groupcode < 0) {        
167                     goto stopit;
168                 }
169                 else if (groupcode != 2) {
170                     continue;
171                 }
172                 else if (strstr(linbuf, "ENTITIES")) {
173                     break;
174                 }
175             }
176         }
177     }
178     while (!feof(infile)) {     
179         // scan ENTITIES section
180         char linbuf[BUFSIZE];
181         int groupcode = getline(infile, linbuf, BUFSIZE);
182 
183         if (groupcode < 0) {        
184             // get a group code and a line
185             goto stopit;
186         }
187         else if (groupcode < 10) {  
188             // cardinal group codes
189             switch(groupcode) {
190             case 0: // start of entity, table, file sep
191                 if (strstr(linbuf, "EOF")) {
192                     writeobj(items, curobj); // dump object
193                     goto stopit;
194                 }
195                 if (strstr(linbuf, "ENDSEC")) {
196                     writeobj(items, curobj); // dump object
197                     goto find;
198                 }
199                 writeobj(items, curobj);    // dump old object
200                 curobj[0] = '\0'; // reset object
201                 curcolor = 7;
202                 strcpy(curobj, linbuf); // get new
203                 break;
204             case 1: // primary text value for entity (?)*/
205                 break;
206             case 2: // block name, attribute tag, etc
207             case 3: // other names
208             case 4:
209                 break;
210             case 5: // entity handle (hex string)
211                 break;
212             case 6: // line type name
213                 break;
214             case 7: // text style name
215                 break;
216             case 8: // layer name
217                 break;
218             case 9: // variable name ID (only in header)*/
219                 break;
220             }
221         }
222         else if (groupcode >= 10 && groupcode < 19) {
223             // Some X coord
224             sscanf(linbuf, "%f", &(xcoords[groupcode-10]));
225         }
226         else if (groupcode >= 20 && groupcode < 29) {
227             // Some Y coord
228             sscanf(linbuf, "%f", &(ycoords[groupcode-20]));
229         }
230         else if (groupcode >= 30 && groupcode < 38) {
231             // Some Z coord
232             sscanf(linbuf, "%f", &(zcoords[groupcode-30]));
233         }
234         else if (groupcode == 38) {
235             // entity elevation if nonzero
236         }
237         else if (groupcode == 39) {
238             // entity thickness if nonzero
239         }
240         else if (groupcode >= 40 && groupcode < 49) {
241             // misc floats
242             sscanf(linbuf, "%f", &(floats[groupcode-40]));
243         }
244         else if (groupcode == 49) {
245             // repeated value groups
246         }
247         else if (groupcode >= 50 && groupcode < 59) {
248             // misc angles
249             sscanf(linbuf, "%f", &(angles[groupcode-50]));
250         }
251         else if (groupcode == 62) {
252             // Color number
253             sscanf(linbuf, "%6d", &curcolor);
254         }
255         else if (groupcode == 66) {
256             // "entities follow" flag
257         }
258         else if (groupcode >= 70 && groupcode < 79) {
259             // misc ints
260             sscanf(linbuf, "%d", &(ints[groupcode-70]));
261         }
262         else if (groupcode == 210 || groupcode == 220 || groupcode == 230) {    
263             // X, Y, Z components of extrusion direction
264         }
265     }
266 
267 stopit: 
268     return 0;
269 }
.fi
.SS "void writeobj (vector< \fBDXF_ENTITY_ITEM\fP > * items, char curobj[80])"

.PP
dxf_parse\&.cpp 파일의 35 번째 라인에서 정의되었습니다\&.
.PP
.nf
36 {
37     if (strstr(curobj, "LINE")) {   
38         // a VERY skinny triangle!
39         DXF_ENTITY_ITEM e;
40         e\&.type  = ET_LINE;
41         e\&.x0 = xcoords[0], e\&.y0 = ycoords[0], e\&.z0 = zcoords[0];
42         e\&.x1 = xcoords[1], e\&.y1 = ycoords[1], e\&.z1 = zcoords[1];
43         items->push_back (e);
44 
45         //debug ("DXF LD: LINE <%g %g %g> <%g %g %g>", 
46         //  xcoords[0], ycoords[0], zcoords[0], xcoords[1], ycoords[1], zcoords[1]);
47         return;
48     }
49     else if (strstr(curobj, "POINT")) {
50         // an itty, bitty sphere!
51         //debug ("DXF LD: POINT <%g %g %g>",  
52         //  xcoords[0], ycoords[0], zcoords[0]);
53         return;
54     }
55     else if (strstr(curobj, "CIRCLE")) {
56         // a VERY short cylinder!
57         //debug ("DXF LD: CIRCLE <%g %g %g> <%g>", xcoords[0], ycoords[0], zcoords[0], floats[0]);
58         return;
59     }
60     else if (strstr(curobj, "ARC")) {
61         // not implemented for now
62         return;
63     }
64     else if (strstr(curobj, "TRACE")) {
65         // 2 back-to-back triangles
66         //debug ("DXF LD: TRACE <%g %g %g> <%g %g %g> <%g %g %g> <%g %g %g>", 
67         //  xcoords[0], ycoords[0], zcoords[0], xcoords[1], ycoords[1], zcoords[1], xcoords[2], ycoords[2], zcoords[2], xcoords[3], ycoords[3], zcoords[3]);
68         return;
69     }
70     else if (strstr(curobj, "SOLID")) {
71         // 1 or 2 triangles
72         //debug ("DXF LD: SOLID <%g %g %g> <%g %g %g> <%g %g %g> <%g %g %g>", 
73         //  xcoords[0], ycoords[0], zcoords[0], xcoords[1], ycoords[1], zcoords[1], xcoords[2], ycoords[2], zcoords[2], xcoords[3], ycoords[3], zcoords[3]);
74         return;
75     }
76     else if (strstr(curobj, "TEXT")) {  
77         // not implemented for now
78         return;
79     }
80     else if (strstr(curobj, "SHAPE")) {
81         // these look very hard
82         return;
83     }
84     else if (strstr(curobj, "BLOCK")) {
85         // these look very hard
86         return;
87     }
88     else if (strstr(curobj, "ENDBLK")) {
89         // these look very hard
90         return;
91     }
92     else if (strstr(curobj, "INSERT")) {
93         // these look very hard
94         return;
95     }
96     else if (strstr(curobj, "ATTDEF")) {
97         // not implemented for now
98         return;
99     }
100     else if (strstr(curobj, "ATTRIB")) {
101         // not implemented for now
102         return;
103     }
104     else if (strstr(curobj, "POLYLINE")) {
105         // these look fairly hard
106         return;
107     }
108     else if (strstr(curobj, "VERTEX")) {
109         // these look fairly hard
110         return;
111     }
112     else if (strstr(curobj, "SEQEND")) {
113         // these look fairly hard
114         return;
115     }
116     else if (strstr(curobj, "3DLINE")) {
117         // a VERY skinny triangle!
118         //debug ("DXF LD: 3DLINE <%g %g %g> <%g %g %g>", 
119         //  xcoords[0], ycoords[0], zcoords[0], xcoords[1], ycoords[1], zcoords[1]);
120         return;
121     }
122     else if (strstr(curobj, "3DFACE")) {
123         // 1 or 2 triangles
124         //debug ("DXF LD: 3DFACE <%g %g %g> <%g %g %g> <%g %g %g> <%g %g %g>", 
125         //  xcoords[0], ycoords[0], zcoords[0], xcoords[1], ycoords[1], zcoords[1], xcoords[2], ycoords[2], zcoords[2], xcoords[3], ycoords[3], zcoords[3]);
126         return;
127     }
128     else if (strstr(curobj, "DIMENSION")) {
129         // not implemented for now
130         return;
131     }
132     return; // no current object defined\&.\&.\&.
133 }
.fi
.SH "변수 문서화"
.PP 
.SS "float angles[10]\fC [static]\fP"

.PP
dxf_parse\&.cpp 파일의 12 번째 라인에서 정의되었습니다\&.
.SS "float floats[10]\fC [static]\fP"

.PP
dxf_parse\&.cpp 파일의 12 번째 라인에서 정의되었습니다\&.
.SS "int ints[10]\fC [static]\fP"

.PP
dxf_parse\&.cpp 파일의 13 번째 라인에서 정의되었습니다\&.
.SS "float xcoords[10]\fC [static]\fP"

.PP
dxf_parse\&.cpp 파일의 11 번째 라인에서 정의되었습니다\&.
.SS "float ycoords[10]\fC [static]\fP"

.PP
dxf_parse\&.cpp 파일의 11 번째 라인에서 정의되었습니다\&.
.SS "float zcoords[10]\fC [static]\fP"

.PP
dxf_parse\&.cpp 파일의 11 번째 라인에서 정의되었습니다\&.
.SH "작성자"
.PP 
소스 코드로부터 Test를 위해 Doxygen에 의해 자동으로 생성됨\&.
