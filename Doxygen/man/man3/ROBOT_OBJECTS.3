.TH "ROBOT_OBJECTS" 3 "화 1월 27 2015" "Version Ver 1.0.0" "Test" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ROBOT_OBJECTS \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <robot object\&.h>\fP
.SS "Public 멤버 함수"

.in +1c
.ti -1c
.RI "\fBROBOT_OBJECTS\fP (void)"
.br
.ti -1c
.RI "\fB~ROBOT_OBJECTS\fP (void)"
.br
.ti -1c
.RI "void \fBLocalization\fP ()"
.br
.ti -1c
.RI "void \fBUpdate\fP ()"
.br
.ti -1c
.RI "void \fBPop\fP (int num)"
.br
.ti -1c
.RI "void \fBAdd\fP (double x, double y)"
.br
.ti -1c
.RI "void \fBAdd\fP (CPoint p)"
.br
.ti -1c
.RI "void \fBAdd\fP ()"
.br
.ti -1c
.RI "CString \fBData\fP (int i)"
.br
.in -1c
.SS "Public 속성"

.in +1c
.ti -1c
.RI "\fBPUPPET\fP \fBrobots\fP [\fBMAX_ROBOT_COUNT\fP]"
.br
.ti -1c
.RI "int \fBrobot_count\fP"
.br
.in -1c
.SS "Private 멤버 함수"

.in +1c
.ti -1c
.RI "void \fBLocalization\fP (\fBPUPPET\fP *p)"
.br
.in -1c
.SH "상세한 설명"
.PP 
robot object\&.h 파일의 80 번째 라인에서 정의되었습니다\&.
.SH "생성자 & 소멸자 문서화"
.PP 
.SS "ROBOT_OBJECTS::ROBOT_OBJECTS (void)"

.PP
robot object\&.cpp 파일의 116 번째 라인에서 정의되었습니다\&.
.PP
.nf
117 {
118     for(int i=0;i<MAX_ROBOT_COUNT;i++)
119     {
120         robots[i]\&.point\&.x = (LONG)0\&.0;
121         robots[i]\&.point\&.y = (LONG)0\&.0;
122         robots[i]\&.theta = 0\&.0;
123     }
124     robot_count = 0;
125 }
.fi
.SS "ROBOT_OBJECTS::~ROBOT_OBJECTS (void)"

.PP
robot object\&.cpp 파일의 127 번째 라인에서 정의되었습니다\&.
.PP
.nf
128 {
129 
130 }
.fi
.SH "멤버 함수 문서화"
.PP 
.SS "void ROBOT_OBJECTS::Add (double x, double y)"

.PP
robot object\&.cpp 파일의 251 번째 라인에서 정의되었습니다\&.
.PP
.nf
252 {
253     if(robot_count < MAX_ROBOT_COUNT)
254     {
255         robots[robot_count]\&.Reset();
256         robots[robot_count]\&.point\&.x = (LONG)x;
257         robots[robot_count]\&.point\&.y = (LONG)y;
258         robots[robot_count]\&.theta = (double)((rand() / 360)*D2R);
259         robot_count++;
260     }
261 }
.fi
.SS "void ROBOT_OBJECTS::Add (CPoint p)"

.PP
robot object\&.cpp 파일의 263 번째 라인에서 정의되었습니다\&.
.PP
.nf
264 {
265     if(robot_count < MAX_ROBOT_COUNT)
266     {
267         robots[robot_count]\&.Reset();
268         robots[robot_count]\&.point\&.x = (LONG)p\&.x;
269         robots[robot_count]\&.point\&.y = (LONG)p\&.y;
270         robots[robot_count]\&.theta = (double)((rand() / 360)*D2R);
271         robot_count++;
272     }
273 }
.fi
.SS "void ROBOT_OBJECTS::Add ()"

.PP
robot object\&.cpp 파일의 275 번째 라인에서 정의되었습니다\&.
.PP
.nf
276 {
277     if(robot_count < MAX_ROBOT_COUNT)
278     {
279         robots[robot_count]\&.Reset();
280         robots[robot_count]\&.point\&.x = (LONG)(rand() % MAX_STAGE_LENGTH - MAX_STAGE_HALF_LENGTH);
281         robots[robot_count]\&.point\&.y = (LONG)(rand() % MAX_STAGE_LENGTH - MAX_STAGE_HALF_LENGTH);
282         robots[robot_count]\&.theta = (double)((rand() / 360)*D2R);
283         robot_count++;
284     }
285 }
.fi
.SS "CString ROBOT_OBJECTS::Data (int i)"

.PP
robot object\&.cpp 파일의 203 번째 라인에서 정의되었습니다\&.
.PP
.nf
204 {
205     CString out,str2add;
206     out\&.Format("");
207 
208     str2add\&.Format("\r\n\r\n==== %d 번째 로봇 ====\r\n",i);
209     out += str2add;
210 
211     str2add\&.Format(" X = %\&.1f\r\n Y = %\&.1f\r\n Theta = %\&.1f\r\n",(double)(robots[i]\&.point\&.x), (double)(robots[i]\&.point\&.y), robots[i]\&.theta);
212     out += str2add;
213 
214     str2add\&.Format(" v = %\&.3f cm/s\r\n w = %\&.3f deg/s\r\n", robots[i]\&.v, robots[i]\&.w);
215     out += str2add;
216 
217     str2add\&.Format(" Body Rad = %\&.1f\r\n Head Rad = %\&.1f\r\n Neck Length = %\&.1f\r\n",robots[i]\&.body_radius, robots[i]\&.head_radius, robots[i]\&.neck_length);
218     out += str2add;
219 
220     str2add\&.Format(" Body Color: (%d, %d, %d) \r\n",robots[i]\&.body_color\&.R,robots[i]\&.body_color\&.G,robots[i]\&.body_color\&.B);
221     out += str2add;
222     str2add\&.Format(" Head Color: (%d, %d, %d) \r\n",robots[i]\&.head_color\&.R,robots[i]\&.head_color\&.G,robots[i]\&.head_color\&.B);
223     out += str2add;
224     
225 
226 
227 //  ch\&.etc       = IDLE;
228 //  ch\&.level = IDLE;
229 //  ch\&.main      = IDLE;
230 //  ch\&.sub       = IDLE;
231 //  ch\&.type      = IDLE;
232 
233 
234     return out;
235 
236 }
.fi
.SS "void ROBOT_OBJECTS::Localization ()"

.PP
robot object\&.cpp 파일의 181 번째 라인에서 정의되었습니다\&.
.PP
.nf
182 {
183     for(int i=0; i<robot_count; i++)
184     {
185         Localization(&robots[i]);
186     }
187 }
.fi
.SS "void ROBOT_OBJECTS::Localization (\fBPUPPET\fP * p)\fC [private]\fP"

.PP
robot object\&.cpp 파일의 189 번째 라인에서 정의되었습니다\&.
.PP
.nf
190 {
191     double x_inc, y_inc, theta_inc;
192     x_inc = p->v * cos(p->theta);
193     y_inc = p->v * sin(p->theta);
194     theta_inc = p->w;
195 
196     p->point\&.x += (LONG)x_inc;
197     p->point\&.y += (LONG)y_inc;
198     p->theta += theta_inc;
199 
200 }
.fi
.SS "void ROBOT_OBJECTS::Pop (int num)"

.PP
robot object\&.cpp 파일의 238 번째 라인에서 정의되었습니다\&.
.PP
.nf
239 {
240     if(num < robot_count)
241     {
242 //      for(int i=0; i<num; i++)
243 //          robots[i]\&.Copy(robots[i+1]);
244 
245         for(int i=num; i<robot_count-1; i++)
246             robots[i]\&.Copy(robots[i+1]);
247 
248         robot_count--;
249     }
250 }
.fi
.SS "void ROBOT_OBJECTS::Update ()"

.PP
robot object\&.cpp 파일의 133 번째 라인에서 정의되었습니다\&.
.PP
.nf
134 {
135     for(int i=0; i<robot_count; i++)
136     {
137 
138         if( abs( robots[i]\&.point\&.x ) > MAX_STAGE_HALF_LENGTH || abs( robots[i]\&.point\&.y ) > MAX_STAGE_HALF_LENGTH )
139         {//영역을 벗어나려고 하면 위치를 강제로\&. 
140             double dis2go = 10\&.0;
141             robots[i]\&.theta = _Deg(180 + robots[i]\&.theta);
142             robots[i]\&.point\&.x += (LONG)(dis2go * cos(robots[i]\&.theta));    
143             robots[i]\&.point\&.y += (LONG)(dis2go * sin(robots[i]\&.theta));    
144         }
145         else
146         {//영역 안에 있을 때 랜덤한 움직임
147 
148             robots[i]\&.SetV(7);
149             robots[i]\&.SetW(robots[i]\&.w += ((double)isRandom(-10,10))/1000);
150         }
151 
152         for(int j=0; j<robot_count; j++)
153         {//충돌 조건 
154             if(j==i)    continue;
155             if(robots[i]\&.isMeet(&robots[j]))
156             {//로봇과 로봇이 만났을 경우에 
157 
158                 //현재는 큰놈이 작은놈을 먹도록 되어있다\&. -> 먹고나서 커진다\&. 
159                 if(robots[i]\&.body_radius >= robots[j]\&.body_radius)
160                 {
161                     robots[i]\&.body_radius += robots[j]\&.body_radius/3;
162                     robots[i]\&.head_radius += robots[j]\&.head_radius/3;
163                     robots[i]\&.neck_length += robots[j]\&.neck_length/3;
164                     Pop(j);
165                 }
166                 else
167                 {
168                     robots[j]\&.body_radius += robots[i]\&.body_radius/3;
169                     robots[j]\&.head_radius += robots[i]\&.head_radius/3;
170                     robots[j]\&.neck_length += robots[i]\&.neck_length/3;
171                     Pop(i);
172                 }
173                 continue;
174             }
175         }
176 
177     }
178 }
.fi
.SH "멤버 데이타 문서화"
.PP 
.SS "int ROBOT_OBJECTS::robot_count"

.PP
robot object\&.h 파일의 106 번째 라인에서 정의되었습니다\&.
.SS "\fBPUPPET\fP ROBOT_OBJECTS::robots[\fBMAX_ROBOT_COUNT\fP]"

.PP
robot object\&.h 파일의 105 번째 라인에서 정의되었습니다\&.

.SH "작성자"
.PP 
소스 코드로부터 Test를 위해 Doxygen에 의해 자동으로 생성됨\&.
