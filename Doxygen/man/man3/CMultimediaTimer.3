.TH "CMultimediaTimer" 3 "화 1월 27 2015" "Version Ver 1.0.0" "Test" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CMultimediaTimer \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <MultimediaTimer\&.h>\fP
.SS "Public 멤버 함수"

.in +1c
.ti -1c
.RI "\fBCMultimediaTimer\fP ()"
.br
.ti -1c
.RI "\fB~CMultimediaTimer\fP ()"
.br
.ti -1c
.RI "virtual void \fBOnTimer\fP (\fBUINT\fP timerId, \fBUINT\fP msg)"
.br
.ti -1c
.RI "void \fBStart\fP (\fBUINT\fP executionPeriod)"
.br
.ti -1c
.RI "void \fBStop\fP ()"
.br
.ti -1c
.RI "bool \fBIsRunning\fP ()"
.br
.in -1c
.SS "정적 Public 멤버 함수"

.in +1c
.ti -1c
.RI "static \fBDWORD\fP \fBGetTime\fP ()"
.br
.ti -1c
.RI "static void \fBSleep\fP (\fBDWORD\fP ms)"
.br
.in -1c
.SS "Public 속성"

.in +1c
.ti -1c
.RI "\fBUINT\fP \fB_period\fP"
.br
.in -1c
.SS "Private 속성"

.in +1c
.ti -1c
.RI "\fBUINT\fP \fB_timerRes\fP"
.br
.ti -1c
.RI "\fBDWORD\fP \fB_timerId\fP"
.br
.in -1c
.SH "상세한 설명"
.PP 
MultimediaTimer\&.h 파일의 18 번째 라인에서 정의되었습니다\&.
.SH "생성자 & 소멸자 문서화"
.PP 
.SS "CMultimediaTimer::CMultimediaTimer ()"

.PP
MultimediaTimer\&.cpp 파일의 17 번째 라인에서 정의되었습니다\&.
.PP
.nf
17                                     :
18     _timerRes (0), _timerId (-1)
19 {
20     TIMECAPS tc;
21     const int TARGET_RESOLUTION  = 1;   // 1-millisecond target resolution
22 
23     timeGetDevCaps(&tc, sizeof(TIMECAPS));
24     _timerRes = min(max(tc\&.wPeriodMin, TARGET_RESOLUTION), tc\&.wPeriodMax);
25     timeBeginPeriod(_timerRes); 
26 }
.fi
.SS "CMultimediaTimer::~CMultimediaTimer ()"

.PP
MultimediaTimer\&.cpp 파일의 28 번째 라인에서 정의되었습니다\&.
.PP
.nf
29 {
30     Stop ();
31 
32     if (0 < _timerRes) {
33         timeEndPeriod (_timerRes);
34     }
35 }
.fi
.SH "멤버 함수 문서화"
.PP 
.SS "\fBDWORD\fP CMultimediaTimer::GetTime ()\fC [static]\fP"

.PP
MultimediaTimer\&.cpp 파일의 58 번째 라인에서 정의되었습니다\&.
.PP
.nf
59 {
60     return timeGetTime(); 
61 }
.fi
.SS "bool CMultimediaTimer::IsRunning ()\fC [inline]\fP"

.PP
MultimediaTimer\&.h 파일의 31 번째 라인에서 정의되었습니다\&.
.PP
.nf
31 { return _timerId != -1; }
.fi
.SS "virtual void CMultimediaTimer::OnTimer (\fBUINT\fP timerId, \fBUINT\fP msg)\fC [inline]\fP, \fC [virtual]\fP"

.PP
MultimediaTimer\&.h 파일의 27 번째 라인에서 정의되었습니다\&.
.PP
.nf
27 { }
.fi
.SS "void CMultimediaTimer::Sleep (\fBDWORD\fP ms)\fC [static]\fP"

.PP
MultimediaTimer\&.cpp 파일의 63 번째 라인에서 정의되었습니다\&.
.PP
.nf
64 {
65     ::Sleep (ms);
66 }
.fi
.SS "void CMultimediaTimer::Start (\fBUINT\fP executionPeriod)"

.PP
MultimediaTimer\&.cpp 파일의 43 번째 라인에서 정의되었습니다\&.
.PP
.nf
44 {
45     assert ((int)_timerId < 0);
46     _period = executionPeriod;
47     _timerId = timeSetEvent (executionPeriod, _timerRes, OneShotTimer, (DWORD)this, TIME_PERIODIC);
48 }
.fi
.SS "void CMultimediaTimer::Stop ()"

.PP
MultimediaTimer\&.cpp 파일의 50 번째 라인에서 정의되었습니다\&.
.PP
.nf
51 {
52     if (0 <=_timerId) {
53         timeKillEvent (_timerId);  // cancel the event
54         _timerId = -1;
55     }
56 }
.fi
.SH "멤버 데이타 문서화"
.PP 
.SS "\fBUINT\fP CMultimediaTimer::_period"

.PP
MultimediaTimer\&.h 파일의 37 번째 라인에서 정의되었습니다\&.
.SS "\fBDWORD\fP CMultimediaTimer::_timerId\fC [private]\fP"

.PP
MultimediaTimer\&.h 파일의 21 번째 라인에서 정의되었습니다\&.
.SS "\fBUINT\fP CMultimediaTimer::_timerRes\fC [private]\fP"

.PP
MultimediaTimer\&.h 파일의 20 번째 라인에서 정의되었습니다\&.

.SH "작성자"
.PP 
소스 코드로부터 Test를 위해 Doxygen에 의해 자동으로 생성됨\&.
